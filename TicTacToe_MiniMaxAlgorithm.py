import math
import random


# checks empty slots in board
def checkPossibleMoves(state):
    moves = []
    for key in state.keys():
        if state[key] == '-':
            moves.append(key)
    return moves


def checkWithDraw(state):
    for key in state.keys():
        if state[key] == '-':
            return False
    return True


def checkWin(state):
    if state[1] == state[2] and state[1] == state[3] and state[1] != '-':
        return True
    elif state[4] == state[5] and state[4] == state[6] and state[4] != '-':
        return True
    elif state[7] == state[8] and state[7] == state[9] and state[7] != '-':
        return True
    elif state[1] == state[5] and state[1] == state[9] and state[1] != '-':
        return True
    elif state[3] == state[5] and state[3] == state[7] and state[3] != '-':
        return True
    elif state[1] == state[4] and state[1] == state[7] and state[1] != '-':
        return True
    elif state[2] == state[5] and state[2] == state[8] and state[2] != '-':
        return True
    elif state[3] == state[6] and state[3] == state[9] and state[3] != '-':
        return True

    return False


class TicTacToe:
    def __init__(self):
        self.board = {
            1: '-', 2: '-', 3: '-',
            4: '-', 5: '-', 6: '-',
            7: '-', 8: '-', 9: '-'}

        self.Min = 'O'
        self.Max = 'X'

        self.moves = {'O': 0, 'X': 0}
        self.successors = {'O': 0, 'X': 0}

    def printBoard(self):
        print(self.board[1] + ' | ' + self.board[2] + ' | ' + self.board[3])
        print(self.board[4] + ' | ' + self.board[5] + ' | ' + self.board[6])
        print(self.board[7] + ' | ' + self.board[8] + ' | ' + self.board[9])
        print()

    # Choose whether you want to play with or without alpha beta pruning
    def chooseMethod(self):
        m = int(input("How Do You Want To Play ?"
                      "\n1. MinMax Without Pruning"
                      "\n2. MinMax Wit Alpha Beta Pruning:"
                      "\nEnter Your Choice : "))
        if m == 1:
            return self.bestMoveWithoutPruning
        else:
            return self.bestMoveWithPruning

    # game driver function
    def startGame(self, miniMaxMethod):
        print("Game Started.")
        # toss
        turn = random.choice([self.Min, self.Max])

        # Gameplay
        while not checkWithDraw(self.board) and not checkWin(self.board):
            print("Min's Turn.") if turn == 'O' else print("Max's Turn\n")
            # if its player turn then get input and pass into insert function
            if turn == self.Min:
                turnTaken = self.insertOnBoard(turn, miniMaxMethod(turn))
            # if computers turn get best move through minimax
            elif turn == self.Max:
                turnTaken = self.insertOnBoard(turn, miniMaxMethod(turn))
            # turn switch if valid turn was taken
            if turnTaken:
                self.moves[turn] += 1
                turn = self.Max if turn == self.Min else self.Min
            else:
                print("Invalid Try")
        # Total moves
        print("Total Moves Taken By Min Are : ", self.moves[self.Min])
        print("Total Moves Taken By Max Are : ", self.moves[self.Max])
        # Total successors generated
        print("Total Successors Generated By Min Are : ", self.successors[self.Min])
        print("Total Successors Generated By Max Are : ", self.successors[self.Max])

    def spaceVacant(self, position):
        if self.board[position] == '-':
            return True
        return False

    # inserts players mark on board
    def insertOnBoard(self, player, position):
        if self.spaceVacant(position):
            self.board[position] = player
            self.printBoard()

            if checkWithDraw(self.board):
                print('Game Draw! ')
            elif checkWin(self.board):
                print("Min Won Game!") if player == 'O' else print("Max Won Game!")
            return True
        return False

    # return the best move with minimax without pruning
    def bestMoveWithoutPruning(self, player):
        bestMove = -1
        bestScore = -math.inf

        state = self.board.copy()
        # checking every possible move and sending it to minimax so, it can decide which one is best
        for move in checkPossibleMoves(state):
            state[move] = player
            score = self.minMaxWithoutPruning(state, False, player)
            state[move] = '-'
            self.successors[player] += 1

            if score > bestScore:
                bestScore = score
                bestMove = move

        return bestMove

    def minMaxWithoutPruning(self, state, isMaximizing, player):
        if checkWin(state):
            return -1 if isMaximizing else 1

        elif checkWithDraw(state):
            return 0

        if isMaximizing:
            sign = player
        else:
            sign = 'X' if player == 'O' else 'O'

        scores = []
        # check possible moves and recursively calls itself
        for move in checkPossibleMoves(state):
            state[move] = sign
            scores.append(self.minMaxWithoutPruning(state, not isMaximizing, player))
            self.successors[player] += 1
            state[move] = '-'

        return max(scores) if isMaximizing else min(scores)

    # return the best move with minimax with alpha beta pruning
    def bestMoveWithPruning(self, player):
        depth = 0
        bestMove = -1
        bestScore = -math.inf
        alpha = -math.inf
        beta = math.inf

        state = self.board.copy()
        # checking possible moves and sending it to minimax so, it can decide which one is best
        for move in checkPossibleMoves(state):
            state[move] = player
            score = self.minMaxWithPruning(state, False, player, depth + 1, alpha, beta)
            state[move] = '-'
            self.successors[player] += 1

            if score > bestScore:
                bestScore = score
                bestMove = move

        return bestMove

    def minMaxWithPruning(self, state, isMaximizing, player, depth, alpha, beta):
        if checkWin(state):
            return -1 if isMaximizing else 1

        elif checkWithDraw(state):
            return 0

        if isMaximizing:
            sign = player
            bestScore = -math.inf
        else:
            sign = 'X' if player == 'O' else 'O'
            bestScore = math.inf

        # check possible moves and recursively calls itself
        for move in checkPossibleMoves(state):
            state[move] = sign
            score = self.minMaxWithPruning(state, not isMaximizing, player, depth + 1, alpha, beta)
            self.successors[player] += 1
            state[move] = '-'

            # alpha beta pruning
            if isMaximizing:
                bestScore = max(bestScore, score)
                alpha = max(alpha, bestScore)

            else:
                bestScore = min(bestScore, score)
                beta = min(beta, bestScore)

            # if min have found state which is as good as max state so break
            if beta <= alpha:
                break

        return bestScore


# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    game = TicTacToe()
    game.startGame(game.chooseMethod())
